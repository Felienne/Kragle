\documentclass{sig-alternate}

\usepackage{url}
\usepackage{graphicx}

\newcommand{\nPrograms}{250,166}
\newcommand{\nAnalyzedPrograms}{247,798}
\newcommand{\nemptyPrograms}{14,307}
\newcommand{\nScriptPrograms}{233,491}
\newcommand{\nProgramsWithClones}{67,177}
\newcommand{\nLOC}{36,085,654}
\newcommand{\nscripts}{4,049,356}
\newcommand{\dup}{\emph{Duplication}~}

\newcommand{\todo}[1]{\textbf{#1}}

\begin{document}
%
% --- Author Metadata here ---
%\conferenceinfo{WOODSTOCK}{'97 El Paso, Texas USA}
% --- End of Author Metadata ---

\title{How Kids Code and How We Know:\\An Exploratory Study on the Scratch Repository }

\numberofauthors{1}
\author{
% 1st. author
\alignauthor
(anonymized submission)
%Ben Trovato\titlenote{Dr.~Trovato insisted his name be first.}\\
%       \affaddr{Institute for Clarity in Documentation}\\
%       \affaddr{1932 Wallamaloo Lane}\\
%       \affaddr{Wallamaloo, New Zealand}\\
%       \email{trovato@corporation.com}
% 2nd. author
%\alignauthor
%G.K.M. Tobin\titlenote{The secretary disavows
%any knowledge of this author's actions.}\\
%       \affaddr{Institute for Clarity in Documentation}\\
%       \affaddr{P.O. Box 1212}\\
%       \affaddr{Dublin, Ohio 43017-6221}\\
%       \email{webmaster@marysville-ohio.com}
}

%\date{30 July 1999}

\maketitle
\begin{abstract}
Block-based programming languages like Scratch, Alice and Blockly are becoming increasingly common as introductory languages in programming education. There is substantial research showing that those visual programming environments are suitable for teaching programming concepts. In this paper we explore the characteristics of Scratch programs. To that end we have scraped the Scratch public repository and retrieved 250.000 projects. We present an analysis of those projects in terms of complexity, used abstractions and programming concepts, and coding style. We found that programming abstraction concepts like functions are not commonly used. We further investigate the presence of code smells and bad programming practices, including code duplication, dead code, long method and large class smells. Our findings indicate that Scratch programs suffer from code smells and especially code duplication.
\end{abstract}

% A category with the (minimum) three required fields
%\category{H.4}{Information Systems Applications}{Miscellaneous}
%A category including the fourth, optional field follows...
%\category{D.2.8}{Software Engineering}{Metrics}[complexity measures, performance measures]

\terms{terms}

\keywords{Scratch, programming practices, code smells, static analysis}

\section{Introduction}

Scratch is a programming language developed to teach children programming by enabling them to create games and interactive animations. The public repository of Scratch programs contains over 12 million projects. Scratch is a \emph{block-based} language: users manipulate blocks to program. Block-based languages are visual languages, but also use some successful aspects of text-based languages such as limited text-entry and indentation, and as such are closer to `real', textual programming than other forms of visual programming, like dataflow languages are.

Block-based languages have existed since the eighties, but have recently found adoption as tools for programming education. In addition to Scratch, also Alice~\cite{conway_alice:_1994}, Blockly\footnote{\url{https://developers.google.com/blockly/}} and App Inventor~\cite{wolber_app_2011} are block-languages aimed at novice programmers.

refer to:
Research on the effectiveness of those languages for programming education
Research on programming habits
Our research on smells

The goal of this paper is to obtain a deep understanding of how people program in Scratch and to analyze the characteristics of Scratch programs. Moreover, knowing that bad programming habits and code smells can be harmful, we also want to explore whether they are common. Specifically, the research questions that we are trying to answer are:

\begin{itemize}
\item[RQ1] What are the size and complexity characteristics of Scratch programs?
\item[RQ2] Which coding abstractions and programming concepts and features are commonly used when programming in the Scratch environment?
\item[RQ3] How common are code smells and bad programming practices in Scratch programs?
\end{itemize}

Our study is based on data from the Scratch program repository. By scraping the list of recent programs \todo{link}, we have obtained \nPrograms~public Scratch programs and performed static analysis on them.

The contributions of this paper are as follows:

\begin{itemize}
	\item{A public data set of \nScriptPrograms~Scratch programs (Section \ref{dataset})}
	\item{An empirical evaluation of the data set for answering the aforementioned research questions}
\end{itemize}


\section{Background and Motivation}
\label{sec:background}
Block-based languages go back to 1986, when Glinert introduced the BLOX language~\cite{e._glinert_towards_1986}. BLOX consists of puzzle-like programming statements that can be combined into programs by combining them both vertically and horizontally. After a decade of little activity into block-based languages, they became a research topic again, starting with Alice~\cite{conway_alice:_1994}. More recently, new block-based languages have gained widespread popularity, especially powered by Scratch~\cite{resnick_scratch:_2009} and Blockly\footnote{\url{https://developers.google.com/blockly/}}. Over 100 million students have tried Blockly via Code.org, and the Scratch repository currently hosts over 12 million projects. Unlike in BLOX, in these new block-based languages the programming blocks can only be combined vertically, resembling textual code more.

Since their introduction, studies have demonstrated the applicability of block-based languages as a tool for education. Scratch, for example, was evaluated with a two-hour introductory programming curriculum for 46 subjects aged 14~\cite{meerbaum-salant_learning_2010}. This study indicated that Scratch could be used to teach computer science concepts: analysis of the pre- and post-tests showed a significant improvement after the Scratch course, although some concepts like variables and concurrency remained hard for students.

Moskal \emph{et al.}~\cite{b._moskal_evaluating_2005} compared computer science students who studied Alice before or during their first programming course to students that only took the introductory computer science course. Their results show that exposure to Alice significantly improved students' grades in the course, and their retention in computer science in general over a two year period. A follow-up study by Cooper \emph{et al.}~\cite{cooper_teaching_2003} obtained similar results, showing that a curriculum in Alice resulted in improved grades and higher retention in computer science.

Most convincingly, Price and Barnes performed a controlled experiment in which students were randomly assigned to either a text-based or a block-based interface in  which they had to perform small programming tasks~\cite{price_comparing_2015}. Their experiment showed that students in the block-based interface were more focused and completed more of the activity's goals in less time.

Summarizing the above, we conclude that block-based languages have a clear potential to be a great tool for introductory programming education, in some cases even outperforming text-based languages.

\subsection{Relevant Scratch Concepts}
\label{sec:scratch}
This paper is by no means an introduction into Scratch programming, we refer the reader to \cite{brennan_creative_2014} for an extensive overview. To make this paper self-contained, however, we explain a number of relevant concepts in this section. 

Scratch is a block-based programming language aimed at children, developed by MIT. Scratch can be used to create games and interactive animations, and is available both as a stand-alone application and as a web application. Figure \ref{fig:ui} shows the Scratch user interface in the Chrome browser.

\subsubsection{Sprites}
Scratch code is organized by `sprites': two-dimensional pictures each having their own associated code. Scratch allows users to bring their sprites to life in various ways, for example by moving them in the plane, having them say or think words or sentences via text balloons, but also by having them make sounds, grow, shrink and switch costumes. The Scratch program in Figure \ref{fig:ui}\footnote{\url{https://scratch.mit.edu/projects/97086781/}} consists of one sprite, the cat, which is Scratch's default sprite and logo. The code in the sprite will cause the cat to jump up, say ``hello'', and come back down, when the green flag is clicked, and to make the `meow' sound when the space bar is pressed.

\begin{figure}
	\begin{center}
		\includegraphics[width=\columnwidth]{fig/ui.png}
		\caption{The Scratch user interface consisting of the `cat' sprite on the left, the toolbox with available blocks in the category `motion' in the middle and the code associated with the sprite on the right. The upper right corner shows the actual location of the sprite.}
		\label{fig:ui}
	\end{center}
\end{figure} 

\subsubsection{Signals}
\todo{uitleggen wat een signal is en evt ook al hoe het een kloon vervangt?}

\subsubsection{Events}
Scratch is \emph{event-driven}: all motions, sounds and changes in the looks of sprites are initiated by events. The canonical event is the `when Green Flag clicked', activated by clicking the green flag at the top of the user interface. In addition to the green flag, there are a number of other events possible, including key presses, mouse clicks and input from a computer's microphone or webcam. In the Scratch code in Figure \ref{fig:ui} there are two events: `when Green Flag clicked' and `when space key pressed'.

\subsubsection{Scripts}
Source code within sprites is organized in scripts: a script always starts with an event, followed by a number of blocks. The Scratch code in Figure \ref{fig:ui} has two distinct scripts, one started by clicking on the green flag and one by pressing the space bar. It is possible for a single sprite to have multiple scripts initiated by the same event. In that case, all scripts will be executed simultaneously. For example, the code on the left of Figure \ref{fig:comparison} has five scripts associated with the `when Green Flag clicked' event.

\subsubsection{Remixing}
Scratch programs can be shared by their creators in the global Scratch repository\footnote{\url{https://scratch.mit.edu/explore/projects/all/}}. Shared Scratch programs can be `remixed' by other Scratch users, which means that a copy of this program is placed in the user's own project collection, and can be then further changed. The `remix tree' of projects is public, so users can track which users remix their programs, a bit similar forking in GitHub. Contrary to forking though, changes upstream cannot be integrated back into the original project.

\begin{figure}
	\begin{center}
		\includegraphics[width=6cm]{fig/makeBlockSmall.png}
		\caption{}
		\label{fig:makeBlock}
	\end{center}
\end{figure} 

\begin{figure}
	\begin{center}
		\includegraphics[width=6cm]{fig/useBlockSmall.png}
		\caption{}
		\label{fig:useBlock}
	\end{center}
\end{figure} 


\section{Research design and dataset}
\label{researchDesign}

The main focus of this study is to understand how people program in Scratch by analyzing the characteristics of Scratch programs. To answer our research questions, we conducted an empirical quantitative evaluation of program data we collected from the Scratch repository. The dataset is described in Section \ref{dataset}. Below, we present how we approached each research question.

\textbf{RQ1} What are the size and complexity characteristics of Scratch programs? quantitative analysis, provide and analyze descriptive statistics on the size, complexity metrics, statistical analysis . mentioned taht it was imported to db and done and statistical data from db queries? The outcomes are presented in Section...

\textbf{RQ2} Which coding abstractions and programming concepts and features are commonly used when programming in the Scratch environment? Using the code in the dataset, we perform a detailed statistical analysis of code characteristics to answer RQ2 (Section ??). We manually assigned types to commands/blocks.

\textbf{RQ3} Which code smells and bad programming practices are common in Scratch programs?  to examine if coding style conventions are used, we qualitatively analyze..

\subsection{Dataset}
\label{dataset}
\subsubsection{Obtaining Scratch programs}
We obtained the set of Scratch programs by using a scraping program. Our scraping program called Kragle starts by reading \url{https://scratch.mit.edu/explore/projects/all/} and thus obtaining program ids of programs that were most recently shared. Subsequently, Kragle obtains the JSON code for each of the listed programs. In addition to the programs themselves, Kragle also gathers metadata including the numbers of views, loves, favorites and remixes.

 % For a given id $x$ a Scratch programs JSON representation can be obtained via \url{https://cdn.projects.scratch.mit.edu/internalapi/project/x/get}.  Does not fit on the page nicely and might also not be needed?

We ran Kragle on March 2nd 2016 and let it running for 24 hours, when it had obtained a little over 250.000 programs.  Out of the \nPrograms~, we failed to analyze 2.367 programs due to various technical difficulties \todo{add details, I will check a few to see what went wrong - Felienne} 

Kragle, as well as all scraped programs and our analysis files are available via \todo{url} \todo{I do not think we need to describe the fields in the paper, but we need a good readme with the data (I can do that)}

\subsubsection{Analyzing the Scratch programs}
Once we obtained the Scratch programs, we parsed the JSON files according to the specification of the format\footnote{\url{http://wiki.scratch.mit.edu/wiki/Scratch_File_Format_(2.0)}}. This resulted in a list if used blocks per program, with the sprites and the stage of the program. We also assign types to all the blocks, both their shapes and the tab they originate from. For example, When Green Flag Clicked is a \emph{Hat block} from the \emph{Events category}.


\section{Results}

In the following sections we describe the results obtained for each of the research questions through the analysis of the \nAnalyzedPrograms~Scratch projects in our dataset.

\subsection{Program size and complexity}

The dataset is found to contain a relatively small number of projects without any code: \nemptyPrograms (5.77\%). Through random manual sampling we found that in some cases those projects contained sprites and costumes but no code and in others they were entirety empty apart from the Scratch cat added by default. Since those projects are empty in terms of code we excluded them from further analysis, leaving the final number of analyzed non-empty projects to \nScriptPrograms.

\begin{table*}[ht]
	\centering
	\begin{tabular}{lrrrrrr}
		\hline
		&\textbf{mean}&\textbf{min}&\textbf{Q1}&\textbf{median}&\textbf{Q3}&\textbf{max}\\
		\hline
		Sprites with code per project&5.68&1&1&2&5&525\\
		Scripts per project&17.35&1&2&5&12&3038\\
		Maximum indentation per project&4.56&1&3&3&5&488\\
		Lines of code (LOC) per project&154.55&1&12&29&76&34622\\
		LOC in Stage per project&4.80&0&0&0&3&2613\\
		LOC in Sprites per project&115.57&0&10&26&68&34613\\
		LOC in Procedures per project&34.17&0&0&0&0&20552\\
		McCabe Cyclomatic Complexity (CC) per script&1.58&1&1&1&1&246\\
		McCabe CC per procedure script&3.75&1&1&2&4&183\\
		Procedures per project with procedures&11.50&1&1&2&6&847\\
		Arguments per Procedure&0.95&0&0&0&1&53\\
		Numerical arguments per procedure with arguments&1.73&0&1&1&2&22\\
		Text arguments per procedure with arguments&0.28&0&0&0&1&24\\
		Boolean arguments per procedure with arguments&0.13&0&0&0&0&14\\
		Calls per procedure&2.14&0&1&1&2&526\\
		Scripts with calls per procedure&1.13&0&1&1&1&59\\
		Variables per project&2.06&0&0&0&1&340\\
		Scripts utilizing variable&4.97&1&1&3&5&1127\\
		Lists per project&0.55&0&0&0&0&319\\
		Conditional statements per project&10.02&0&0&0&3&5950\\
		Recursive loop statements per project&7.65&0&1&2&5&2503\\
		Broadcast-receive statements per project&8.57&0&0&0&2&2460\\
		\hline
	\end{tabular}
	\caption{Summary statistics from the dataset of \nScriptPrograms  non-empty Scratch projects}
	\label{tbl-size}
\end{table*}

\begin{table*}[ht]
	\centering
	\begin{tabular}{lrr}
		\hline
		&\textbf{number}&\textbf{percentage}\\
		\hline
		Retrieved projects & 250,166 & \\
		Analyzed projects & 247,798 & \\
		Non-empty projects (used for statistics) & \textbf{233,491} & \\

		Projects utilizing variables & 73,577 & 31.51\% \\
		Projects utilizing lists & 9,358 & 4.01\% \\
		Projects with conditional statements & 92,959 & 39.81\% \\
		Projects with recursive loop statements & 180,210 & 77.18\% \\
		Projects with \texttt{repeat until <condition>} statements & 31,739 & 13.59\% \\
		Projects with \texttt{broadcast} - \texttt{receive} statements & 69,039 & 29.57\%\\
		\hline
	\end{tabular}
	\caption{Characteristics in the projects in the dataset}
	\label{tbl-characteristics}
\end{table*}

\begin{figure}
	\centering
	\includegraphics[width=0.45\textwidth]{fig/charts/1sprites}
	\caption{Histogram of the number of sprites in the analyzed projects}
	\label{fig:size-sprites}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=0.45\textwidth]{fig/charts/1scripts}
	\caption{Histogram of the number of scripts in the analyzed projects}
	\label{fig:size-scripts}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=0.45\textwidth]{fig/charts/1locs}
	\caption{Histogram of the lines of code in the analyzed projects}
	\label{fig:size-locs}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=0.45\textwidth]{fig/charts/1indent}
	\caption{Histogram of the maximum code indentation level in the analyzed projects}
	\label{fig:size-indent}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=0.45\textwidth]{fig/charts/3cyclomatic}
	\caption{Histogram of the McCabe cyclomatic complexity of the \nscripts~analyzed scripts}
	\label{fig:cyclomatic}
\end{figure}


In Table \ref{tbl-size} we summarize statistics for metrics related to size and complexity. We use the mean value and the five-number summary to describe the dataset in terms of the number of sprites with code per project (including the stage sprite) and the number of scripts per project, where each script is a code-block of interconnected Scratch blocks. For example, in Figure \ref{fig:ui} the cat sprite contains two scripts. We further measure the lines of code per project, considering each Scratch block to represent exactly one line of code, thus not counting the closing constructs of loops or conditional statements as separate lines. The maximum code indentation level is used as a code complexity metric. It was calculated using the JSON array depth? \todo{felienne, how did we measure this?}. This corresponds to code indentation level returning 1 for all first-level blocks and increasing by 2 for block enclosures in loops or conditional statements. Figures \ref{fig:size-sprites}, \ref{fig:size-scripts}, \ref{fig:size-locs} and \ref{fig:size-indent} plot the distribution of those size metrics.

We find that the majority of Scratch projects are small; 75\% of the projects have up to 5 sprites, 12 scripts and 76 lines of code, while one fourth of the projects have up to 12 lines of code. On the other end, 5\% of the projects (11,712) are found to have more than 18 sprites and 4.8\% (11,214) consist of more than 500 lines of code. The analysis also highlighted some surprisingly large projects: 135 with more than 300 sprites and even 30 projects with more than 20,000 lines of code\footnote{The Scratch identifiers of those projects can be found in \todo{link}}.

The lines of code metric was further analyzed to understand code organization. As shown in Table \ref{tbl-size}, the majority of Scratch code---74.78\% out of \nLOC lines of code---is written within sprites. An additional 3.1\% of the total lines are found in the stage class. More interestingly, the remaining 22.11\% are lines within defined procedures, which are found in only 7.7\% (17,979) of the projects. Those projects that contain procedures use them a lot; almost half of their total lines of code (48.81\%) are lines within procedures.

As a complexity metric we also used the McCabe cyclomatic complexity \cite{mcCabe76},  a quantitative measure of the number of linearly independent paths through a program's source code. This is calculated per script by counting the number of decision points in the script plus one. In Scratch, decision points can be the \texttt{if} and \texttt{if else} blocks. The results of the cyclomatic complexity metric per script are plotted in Figure \ref{fig:cyclomatic}. The majority (78.33\%) of \nscripts scripts contain no decision points, while 13.08\% have a cyclomatic complexity of 2, containing exactly one decision point. The complexity is higher, over 4, for 3.67\% of the scripts. The analysis also highlighted 209 scripts with a cyclomatic complexity over 100 and up to 246\footnote{The Scratch identifiers of those projects can be found in \todo{link}}. Cyclomatic complexity was greater (mean value of 3.32\%) in defined procedures, with 56.46\% of the procedures having at least one decision point.

\noindent
\fbox{
	\begin{minipage}{0.46\textwidth}
		\emph{RQ1: The majority of Scratch projects are small and simple; 75\% of the projects have up to 5 sprites, 12 scripts, 76 lines of code and no decision points. Most code is written in sprites. Few projects (7.7\%) use procedures, but they use them a lot and for more complex code. There exist surprisingly large and complex projects.}
	\end{minipage}}

\subsection{Programming abstractions and concepts}

As a first programming abstraction we investigated the use of procedures. In the dataset we found 206,799 procedures in 17,979 projects. As summarized in Table \ref{tbl-size}, the projects that contain procedures have an average of 11.5 procedures, but with 53.59\% of those projects having up to 2. Figure \ref{fig:proceduresperproject} shows the distribution of procedures in projects. Regarding procedure arguments, we found that 55.57\% have no arguments and 19.48\%\% have only one (shown in Figure \ref{fig:procedurearguments}). The majority of procedure arguments (80.59\%) are numeric, and the least used argument type is the boolean one---6.23\% of the total procedure arguments, found in 5.32\% of the procedures.

\begin{figure}
	\centering
	\includegraphics[width=0.45\textwidth]{fig/charts/6proceduresperproject}
	\caption{Histogram of the number of procedures for the 17,979 projects that include at least one}
	\label{fig:proceduresperproject}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=0.45\textwidth]{fig/charts/5arguments}
	\caption{Histogram of the number of arguments for the procedures in the dataset}
	\label{fig:procedurearguments}
\end{figure}

The use of procedures in projects was further investigated through the procedure calls, summarized in Figure \ref{fig:procedurecalls}. A significant number of the defined procedures (13,036 or 6.3\%) are not called in the projects. Most procedures are called exactly once (62.32\% of them) or twice (15.65\% ) and from exactly one script (85.92\% of them). Examining the origin of procedure calls, we found remarkable that most of the calls (56.09\%) originate from other procedures, and even 1.06\% originate from the same procedure, thus making it recursive. Those recursive procedures are found in 1052 projects.\footnote{list of recursive procedures published \todo{link}}.

\begin{figure}
	\centering
	\includegraphics[width=0.45\textwidth]{fig/charts/7procedurecalls}
	\caption{Histogram of the number of calls of each procedure in the dataset}
	\label{fig:procedurecalls}
\end{figure}

As shown in table \ref{tbl-characteristics}, almost one-third of the projects utilize variables and a small number (4.01\%) utilize lists. The number of variables that is being used is also limited, with only 7.48\% of the projects having 5 or more variables. The distribution of variable and list utilization is shown in Figure \ref{fig:variables}. Exceptional cases exist: the analysis highlighted 842 projects with more than 100 variables and up to 340. Examining the initialization of variables through the \texttt{set <variable> to <value>} blocks, we found that for 4.83\% of all variables this was missing. The scope of variables was also analyzed: As shown in Table \ref{tbl-size}, each variable is used by an average of 4.97 different scripts, with a median value of 3. However, we must note that this measurement might not be entirely accurate, because variables might be defined in the scope of specific sprites. With our dataset we cannot differentiate global from local variables and we would consider local variables defined with the same name in different sprites as global variables.

\begin{figure}
	\centering
	\includegraphics[width=0.45\textwidth]{fig/charts/8variableslists}
	\caption{Histogram of the number of variables and lists utilized in the projects}
	\label{fig:variables}
\end{figure}

Regarding program control features, conditional statements (blocks \texttt{if <condition> then} and \texttt{if <condition> then else}) are used by 39.81\% of the projects. Recursive loops (blocks \texttt{repeat <times>}, \texttt{forever} and \texttt{repeat until <condition>}) are more common, used by 77.18\% of the projects. The most common of the three is the \texttt{forever} block, accounting for 51.86\% of all recursive loops and the least common one is the \texttt{repeat until <condition>} block, accounting for 11.57\% and used in 13.59\% of the total projects.
	
For event management Scratch offers blocks \texttt{broadcast}, \texttt{broadcast and wait} and \texttt{when I receive}. 
Those blocks are utilized by 29.57\% of the projects. \texttt{broadcast and wait} is rarely used, in only 3.87\% of the projects. The events are not always synchronized: 3,33\% of the \texttt{when I receive} blocks were found to wait for a message that is never being broadcasted, while 4,4\% of the \texttt{broadcast} blocks broadcast a message that is not being received. This lack of syncronizations occurs in 18,669 projects (7.99\% of the total non-empty ones).

%user interativity		
\noindent
\fbox{
	\begin{minipage}{0.46\textwidth}
		\emph{RQ2: One third of the projects utilize variables, sometimes without initializing them. 39.81\% of the projects utilize conditional statements and 77.18\% recursive loops, but conditional recursion is rarely used. 29.57\% of the projects utilize broadcast and receive blocks, but in 29.57\% of the projects they are not synchronized. Most procedures are called once or twice, from a single script which, in more than half of the cases, is another procedure. Recursive procedure calls exist.}
	\end{minipage}}

\subsection{Code smells}
dead code
duplicates/clones -graph, number of overlapping positioning, number of dead code duplicates
long method
large class
conditional complexity
Dublicated wait block-same trigger caught by more than 1

coding style -naming -functions, sprites, variables
code block positioning - overlapping /visibility

\subsubsection{Clones Detection for Scratch programs}
\label{clone_Detection}

We distinguish three different forms of clones: Exact clones within one sprite, exact clones between sprites of one program, clones of `wait' blocks. This section presents the results of our clone detection algorithm on the \nScriptPrograms~ with scripts.

In total \nProgramsWithClones~(26.9\% of programs with scripts) exhibit one of the three types of cloning.The most common type of cloning is copying entire scripts between sprites. This occurs in 62.939 programs (25.2\%). In 8.220 programs (3.3\%) wait conditions are cloned and in 2.463 files there is a script cloned within a sprite.

\paragraph{Exact clones within one sprite}
In total, we found \todo{x} cases of exact script clones within one sprite. Upon further inspection, we found that some of them consisted of unconnected blocks, as depicted in Figure \ref{fig:Unconnected_clones}. While this is technically a clone, as this is \emph{dead code} and will never be executed, this could be considered unharmful sketching. Looking only at clones starting with an event block, \todo{...} clones remain over \todo{?} files.

\begin{figure}
	\begin{center}
		\includegraphics[width=6cm]{fig/Unconnected_clones.png}
		\caption{Cloned blocks that are not connected to an event. Program id: 12237615}
		\label{fig:Unconnected_clones}
	\end{center}
\end{figure} 


\paragraph{Exact clones between sprites of one program}

\paragraph{Clones of `wait' blocks}
Previous work has established that the cloned `wait' blocks can be harmful when modifying Scratch code, which is the reason why we investigated this particular type of cloning. As outlined in section \todo{?} signals can replaced repeated wait blocks, by catching the condition in one place and broadcasting a signal to all other sprites. This is why we found it interesting to see in how many of the cases where a wait block was cloned, the creator of the program also used signals in their program. This indicates that the concept of signals is known, and hence the duplicate condition is not used because the user is not aware of the alternative. In \todo{...} of the cases the program with the duplicated wait block also contained one or more signals. 



\section{Discussion}

\subsection{Implications}
Our results have some interesting implications for designers of educational programming languages. 

\subsubsection{Unconnected Blocks}
In the whole dataset, not just in the programs with clones, we observe unconnected scripts, scripts without an event block and events without associated code. This is a form of \emph{dead code}, code that will never be executed. Because this dead code caused visual clutter, it would be better to have a separate workspace (much like the `backpack in Scratch' where users can store blocks temporarily and use them later. A programming interface could ask actively encourage users to move unconnected block when they exit the environment to encourage a `clean' working space. 

\subsubsection{Code Clones Between Sprites}
With occurrences in one quarter of the 250 thousand programs, the use of exactly identical clones between sprites is extremely common. In a sense, the Scratch users are not to blame here, Scratch does not support the sharing of procedures between scripts, only within them. So in many cases there is no other way to share the functionality than making a copy. We are not aware of the underlying rationale of the Scratch team that lead to this decision, however it seems that a large part of the Scratch users needs this functionality. 

\subsubsection{Refactoring support for duplicate wait blocks}
In todo{...} of the cases, the programs with duplicate conditions, also signals were present. This means that it is feas




\section{Related Work}
\label{sec:related}

\subsection{Code Smells}
Efforts related to our research include works on code smells, initiated by the work by Fowler~\cite{fowler_refactoring:_1999}. His book gives an overview of code smells and corresponding refactorings. Fowler's work was followed by efforts focused on the automatic identification of code smells by means of metrics. Marinescu~\cite{marinescu_detecting_2001} for instance, uses metrics to identify \emph{suspect} classes: classes which could have design flaws. Lanza and Marinescu~\cite{lanza_object-oriented_2006} explain this methodology in more detail. Alves \emph{et al.}~\cite{alves_deriving_2010} focus on a strategy to obtain thresholds for metrics from a benchmark. Olbrich \emph{et al.} furthermore investigates the changes in smells over time, and discusses their impact~\cite{olbrich_evolution_2009}. Moha \emph{et al.}~\cite{moha_decor:_2010} designed the `DECOR' method which automatically generates a smell detection algorithms from specifications. The CCFinder tool~\cite{kamiya_ccfinder:_2002} finally, aims at detecting clones in source code, which are similar to our \dup smell.

\subsection{Smells beyond the OO paradigm}
In recent times, code smells have been applied to programs outside of the regular programming domain. In our past work, we have, for example, studied code smells within spreadsheets, both at the formula level~\cite{hermans_detecting_2014} and between worksheets~\cite{hermans_detecting_2012}.

More recently, we compared two datasets: one containing spreadsheets which users found unmaintainable, and a version of the same spreadsheets rebuilt by professional spreadsheet developers. The results show that the improved versions suffered from smells to a lesser degree, increasing our confidence that presence of smells indeed coincides with users finding spreadsheets hard to maintain~\cite{jansen_code_2015}.

In addition to spreadsheets, code smells have also been studied in the context of Yahoo! Pipes a web mashup tool. An experiment demonstrated that users preferred the non-smelly versions of Yahoo Pipes programs~\cite{stolee_refactoring_2011}. 

%\subsection{Agile practices in education}
%A third related line of work are research directions where other methods from agile development, like testing and refactoring, have been applied in education. For example, the use of test-driven development has been studied within the context of programming education at university level, using text-based languages in several studies. Most controlled experiments resulted in increased code quality for the group of students using TDD, for example [13] reported on a 35\% reduction in defects, while [14] found 45\%. For an extensive overview of TDD approaches in university programming courses, see [15]. \todo{referenties fixen}

\subsection{Quality of Scratch programs}
Finally, there are other works on the quality of Scratch programs. There is for example the Hairball Scratch extension~\cite{boe_hairball:_2013}, which is a lint-like static analysis tool for Scratch that can detect, for example, unmatched broadcast and receive blocks, infinite loops and duplication. An evaluation of 100 Scratch programs showed that Scratch programs indeed suffer from duplication and bad naming~\cite{moreno_automatic_2014}.

Most related to our study is the work by Moreno \emph{et al.}~\cite{moreno-leon_dr._2015} who gave automated feedback on Scratch programs to 100 children aged 10 to 14. Their results demonstrated that feedback on code quality helped improve students' programming skills.


\bibliographystyle{abbrv}
\bibliography{zotero}
\end{document}
